# -*- coding: utf-8 -*-
import statistics
import scipy.stats as stats
import statsmodels.api as sm
import numpy as np
import matplotlib.pyplot as plt
import pandas as pd 
from statsmodels.graphics.gofplots import qqplot_2samples
from tkinter import Tk
from tkinter.filedialog import askopenfilename

############################################################################################################
#   Eastern Michigan University
#   Backues Lab  
#   Author: Payton Dunning and Steven Backues
#   Last Date Modified: November 18th, 2024
#
#   Includes various statistical functions for analyzing body data generated by SliceStats.
############################################################################################################
#   This program is free software: you can redistribute it and/or modify
#   it under the terms of the GNU General Public License as published by
#   the Free Software Foundation, either version 3 of the License, or
#   (at your option) any later version.
#
#   This program is distributed in the hope that it will be useful,
#   but WITHOUT ANY WARRANTY; without even the implied warranty of
#   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#   GNU General Public License for more details.
#
#   You should have received a copy of the GNU General Public License
#   along with this program.  If not, see <https://www.gnu.org/licenses/>.
############################################################################################################

def main(fileSelectOpt = True, manual = True):
    if manual == True:  
        print(">>Please select an option: ")
        print("[1]: Estimate body size from body slice areas")
        print("[2]: Estimate body number from number of bodies per image")
        print("NOTE: You must generate an estimate of body size and vacuole size before you can estimate body number") 
        programMode = input()
        for _ in range(100):     #So that the user can run multiple tests
            print(">>Please select an option: ")
            print("[1]: Load your data")  ### Works  
            print("[2]: Calculate statistics on your data")   #### Works 
            print("[3]: Perform KS (Kolmogorov-Smirnov test)")   ### Works 
            print("[4]: Generate a Q-Q (quantile-quantile) plot)")   #### Works on local machine
            print("[5]: Generate a Violin Plot")   ### Works on local machine
            print("[6]: Choose to analyze body size or body number")
            print("[0]: Exit Script")
            
            userSelection = input()
            if(userSelection == "1"):
                if programMode == "1":
                    real_slices, sim_slices = loadDataArea(fileSelectOpt)
                elif programMode == "2":
                    real_slices, sim_slices = loadDataNumber(fileSelectOpt)
                else: 
                    print("Please choose either option 1 or 2 by typing that number")
                    print("[1]: Estimate body size from body slice areas")
                    print("[2]: Estimate body number from number of bodies per image")
                    programMode = input() 
            if(userSelection == "2"):
                if programMode == "1":
                    try:
                        findAverage_size(real = real_slices, sim = sim_slices)
                    except:
                        loadDataMessage()
                elif programMode == "2":
                    try:
                        findAverage_num(real = real_slices, sim = sim_slices)
                    except:
                        loadDataMessage()
                else: 
                    print("Please choose either option 1 or 2 by typing that number")
                    print("[1]: Estimate body size from body slice areas")
                    print("[2]: Estimate body number from number of bodies per image")
                    programMode = input() 

            elif(userSelection == "3"):
                try:
                    ksTest(real = real_slices, sim = sim_slices)  
                except:
                    loadDataMessage()
            elif(userSelection == "4"):
                qqPlot(real = real_slices, sim = sim_slices)
            elif(userSelection == "5"):
                violinPlot(real = real_slices, sim = sim_slices, prog = programMode)
            elif(userSelection == "6"):
                print('NOTE!! You will need to reload your data after this for it to be valid')
                print(">>Please select an option: ")    
                print("[1]: Estimate body size from body slice areas")
                print("[2]: Estimate body number from number of bodies per image")
                programMode = input()
               
            elif(userSelection == "0"):
                raise SystemExit
            else:
                print("Please choose an option 0 through 5 by typing that number")
    else:
        print("Coming soon: Automated analysis of multiple runs to find the best mu and sigma ")

def loadDataArea(fileSelectOpt):
    if fileSelectOpt  == True:
        print(">>Select the csv file that contains your real data.  It must have the area of the body slices as the second column:")
        print("(The file selection screen may appear BEHIND your current application)")
        Tk().withdraw()
        inputFile = askopenfilename()
        real_slices = pullData(inputFile, head = None) 
        real_slices.columns = ['image', 'area']
        real_slices = real_slices['area']
        print(">>Now select the csv file that contains your simulated data.  It must have the area of the body slices in a column labeled 'area_scaled':")
        print("(The file selection screen may appear BEHIND your current application)")
        Tk().withdraw()
        inputFile = askopenfilename()
        sim_slices = pullData(inputFile)
        print(sim_slices.head())
        sim_slices = sim_slices[sim_slices.time != 'time'].dropna(axis = 0)  #Removing non-number rows (left-over headers) and NaN's.   
        sim_slices = sim_slices[['area_scaled', 'size_mu', 'size_sigma']].astype(float) #So we can filter by mu or sigma later
        print(sim_slices.head()) 
        print ('Your body area data has been loaded and is ready to use')
        return real_slices, sim_slices

def loadDataNumber(fileSelectOpt):
    if fileSelectOpt  == True:
        print(">>Select the csv file that contains your real data.  It must have the number of body slices per image in the second column:")
        print("(The file selection screen may appear BEHIND your current application)")
        Tk().withdraw()
        inputFile = askopenfilename()
        real_slices = pullData(inputFile, head = None) 
        real_slices.columns = ['image', 'number']
        real_slices = real_slices['number'].astype(int)    
        # Adding zeros for the empty images. Verified to work.  
        noBodies = int(input("How many additional vacuole images were not analyzed because they did not contain any bodies?"))
        addZeros = ([0]*noBodies)
        addZeros = pd.DataFrame(addZeros, dtype = int)
        real_slices = pd.concat([real_slices, addZeros], ignore_index = True) 
        real_slices.columns = ['number']
        real_body_number = real_slices['number'].astype(int)  
        #print(real_slices.dtypes)
        # print(real_body_number.value_counts())  #For verification
        print(">>Now select the csv file that contains your simulated data.  In this case the 'body_number' column contains a unique identifying number for each body sliced:")
        print("(The file selection screen may appear BEHIND your current application)")
        Tk().withdraw()
        inputFile = askopenfilename()
        sim_slices = pullData(inputFile)
        sim_slices = sim_slices[sim_slices.time != 'time']  #Removing non-number rows (left-over headers).  This works 
        sim_body_slices = sim_slices.dropna( axis = 0)   #Removing rows that had "NaN" because there were no bodies captured in that slice
        empty_slice_num = sim_slices.shape[0] - sim_body_slices.shape[0]   #Calculating the number of rows that had "NaN" because there were no bodies captured in that slice
        empty_slices = [0]*empty_slice_num      #Creating a list of 0's to represent the empty slices
        #print(sim_body_slices['time'].value_counts())  #The number of occurences of each timestamp is how many bodies were found in that slice
        sim_body_number = pd.DataFrame({'number': sim_body_slices['time'].value_counts().to_list()})
        sim_body_number = pd.concat([sim_body_number, pd.DataFrame({'number' : empty_slices })], ignore_index = True)   #Adding in the rows for the empty slices
        sim_body_number = sim_body_number['number'].astype(int)
        # print(sim_body_number.value_counts())  #For verification
        print ('Your body number data has been loaded and is ready to use')
        return real_body_number, sim_body_number

def loadDataMessage():
    print('Remember that you must load your data before performing a test, and it must be in the proper format')
    print('The real data must have either body areas or body number in the second column, depending on which you are estimating.')
    print('The simulated data (from slicestats) should have columns labeled "area_scaled" and "body_number.')

def pullData(dataFile, head = 0):
    inStream = open(dataFile, "r")
    slices = pd.read_csv(inStream, header = head)
    inStream.close()
    return slices
 



def findAverage_size(real, sim):
    sim = sim['area_scaled']
    data_sets = [real, sim]
    which_data = 0
    for data in data_sets:
        dataLength = len(data)
        areaAverage = data.mean()
        largestArea = data.max()
        smallestArea = data.min()
        stdDev = data.std()
    
        if which_data == 0:
            print ("\nHere are the statistics for your real data:") 
        else:
            print("\nHere are the statistics for your simulated data:")
        print(f"You have slices from {dataLength} bodies.")
        print("Average Body Slice Area = %d" %(areaAverage))
        print("Largest Body Slice Area = %d" %(largestArea))
        print("Smallest Body Slice Area = %d" %(smallestArea))
        print("Standard Deviation of data set = %d" %(stdDev))
        which_data += 1

def findAverage_num(real, sim):
    data_sets = [real, sim]
    which_data = 0
    for data in data_sets:
        dataLength = len(data)
        areaAverage = data.mean()
        largestArea = data.max()
        smallestArea = data.min()
        stdDev = data.std()
    
        if which_data == 0:
            print ("\nHere are the statistics for your real data:") 
        else:
            print("\nHere are the statistics for your simulated data:")
        print(f"You have slices from {dataLength} images.")
        print("Average Number of Bodies per Image = %d" %(areaAverage))
        print("Largest Number of Bodies per Image = %d" %(largestArea))
        print("Smallest Number of Bodies per Image = %d" %(smallestArea))
        print("Standard Deviation of data set = %d" %(stdDev))
        which_data += 1


def ksTest(real, sim):
    sim = sim['area_scaled']
    ks = stats.ks_2samp(real, sim)
    print (f"The Kolmogorov-Smirnov statistic for your two data sets is {ks.statistic:.3f}, and the p-value is {ks.pvalue:.2E}. \n")
    # ks2 = stats.kstest(real, sim)
    # print (f"Or, the Kolmogorov-Smirnov statistic for your two data sets is {ks2.statistic:.3f}, and the p-value is {ks2.pvalue:.2E}. \n")
    return ks

def multiKS(real, sim):
    mus = sim['size_mu'].value_counts().index.tolist()      # Extracts all of the different values of mu
    mu_list = sorted(mus) 
    print(mu_list)
    print(type(mu_list))
    sigmas = sim['size_sigma'].value_counts().index.tolist()      # Extracts all of the different values of sigma
    sigma_list = sorted(sigmas)
    print(sigma_list)
    print(type(sigma_list))
    multi_ks_results = pd.DataFrame(columns = ['mu', 'sigma', 'ks'])
    for mu in mu_list:
        split_data = sim.loc[sim['size_mu'] == mu]
        for sigma in sigma_list:
            splitter_data = split_data.loc[split_data['size_sigma'] == sigma]
            ks = ksTest(real, splitter_data)
            ks_results = pd.DataFrame([[mu, sigma, float(ks.statistic)]], columns = ['mu', 'sigma', 'ks'])
            multi_ks_results = pd.concat([multi_ks_results, ks_results], ignore_index= True)
    sorted_ks_results = multi_ks_results.sort_values(by = 'ks')        
    return multi_ks_results, sorted_ks_results 

def qqPlot(real, sim):


    sim = sim['area_scaled']
    #statsmodels.graphics.gofplots.qqplot_2samples(statsA, statsB, xlabel='Real Data', ylabel='Simulated Data')
    plotA = sm.ProbPlot(real)
    plotB = sm.ProbPlot(sim)
    qqplot_2samples(plotA,plotB, line='r', xlabel = 'Quantiles of Experimental Data', ylabel ='Quantiles of Simulated Data')  
    
    plt.show()

#END OF qqPlot


def violinPlot(real, sim, prog):
    fig=plt.figure()
    ax = fig.add_subplot(111)
    sim = sim['area_scaled']
    data = [real, sim]
    
    sm.graphics.violinplot(data, ax=ax, labels=["Experimental Data", "Simulated Data"])
    
    ax.set_xlabel("Data Sets")
    if prog == '1':
        ax.set_ylabel("Body Crossectional Area (square nm)")
    elif prog == '2':
        ax.set_ylabel("Number of bodies per slice")
    
    plt.show()


 
main()
