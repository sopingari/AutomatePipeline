# -*- coding: utf-8 -*-
import statistics
import scipy.stats as stats
import statsmodels.api as sm
import numpy as np
import matplotlib.pyplot as plt
import pandas as pd 
from statsmodels.graphics.gofplots import qqplot_2samples
from tkinter import Tk
from tkinter.filedialog import askopenfilename
import seaborn as sns

############################################################################################################
#   Eastern Michigan University
#   Backues Lab  
#   Author: Payton Dunning and Steven Backues
# 
#   Includes various statistical functions for analyzing body data generated by SliceStats.
############################################################################################################
#   This program is free software: you can redistribute it and/or modify
#   it under the terms of the GNU General Public License as published by
#   the Free Software Foundation, either version 3 of the License, or
#   (at your option) any later version.
#
#   This program is distributed in the hope that it will be useful,
#   but WITHOUT ANY WARRANTY; without even the implied warranty of
#   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#   GNU General Public License for more details.
#
#   You should have received a copy of the GNU General Public License
#   along with this program.  If not, see <https://www.gnu.org/licenses/>.
############################################################################################################

def main(fileSelectOpt = True, manual = True):
    if manual == True:  
        print(">>Please select an option: ")
        print("[1]: Estimate body size from body slice areas")
        print("[2]: Estimate body number from number of bodies per image")
        print("NOTE: You must generate an estimate of body size and vacuole size before you can estimate body number") 
        programMode = input()
        for _ in range(100):     #So that the user can run multiple tests
            print(">>Please select an option: ")
            print("[1]: Load your data")  ### Works for both size and number - verified
            print("[2]: Calculate statistics on your data")   #### Works for both size and number - verified
            print("[3]: Perform a KS (Kolmogorov-Smirnov) test")   ### Works for both size and number
            print("[4]: Generate a Q-Q (quantile-quantile) plot)")   #### Works for size; needs to be updated for number
            print("[5]: Generate a Violin Plot")   ### Works for size; needs to be updated for number
            print("[6]: Choose to analyze body size or body number")
            print("[0]: Exit Script")
            
            userSelection = input()
            if(userSelection == "1"):
                if programMode == "1":
                    real_slices, sim_slices = loadDataArea(fileSelectOpt)
                elif programMode == "2":
                    real_slices, sim_slices = loadDataNumber(fileSelectOpt)
                else: 
                    print("Please choose either option 1 or 2 by typing that number")
                    print("[1]: Estimate body size from body slice areas")
                    print("[2]: Estimate body number from number of bodies per image")
                    programMode = input() 
            if(userSelection == "2"):
                if programMode == "1":
                    print(sim_slices.head())
                    try:
                        findAverage_size(real = real_slices, sim = sim_slices)
                    except:
                        loadDataMessage()
                elif programMode == "2":
                    print(sim_slices.head())
                    try:
                        findAverage_num(real = real_slices, sim = sim_slices)
                    except:
                        loadDataMessage()
                else: 
                    print("Please choose either option 1 or 2 by typing that number")
                    print("[1]: Estimate body size from body slice areas")
                    print("[2]: Estimate body number from number of bodies per image")
                    programMode = input() 

            elif(userSelection == "3"):
                if programMode == "1":
                    try:
                        KS_results = multiKS_area(real = real_slices, sim = sim_slices)
                        print(KS_results)
                        KS_heatmap(KS_results)
                    except:
                        loadDataMessage()
                elif programMode == "2":
                    # try:
                    KS_results = multiKS_number(real = real_slices, sim = sim_slices)
                    print(KS_results)
                    KS_heatmap(KS_results)
                    # except:
                    #     loadDataMessage()
                else: 
                    print("Please choose either option 1 or 2 by typing that number")
                    print("[1]: Estimate body size from body slice areas")
                    print("[2]: Estimate body number from number of bodies per image")
                    programMode = input() 

            elif(userSelection == "4"):
                qqPlot_area(real = real_slices, sim = sim_slices)

            elif(userSelection == "5"):
                violinPlot_area(real = real_slices, sim = sim_slices)

            elif(userSelection == "6"):
                print('NOTE!! You will need to reload your data after this for it to be valid')
                print(">>Please select an option: ")    
                print("[1]: Estimate body size from body slice areas")
                print("[2]: Estimate body number from number of bodies per image")
                programMode = input()
               
            elif(userSelection == "0"):
                raise SystemExit
            else:
                print("Please choose an option 0 through 6 by typing that number")
    else:
        print("Coming soon: Automated analysis of multiple runs to find the best mu and sigma ")

def loadDataArea(fileSelectOpt):
    if fileSelectOpt  == True:
        print(">>Select the csv file that contains your real data.  It must have the area of the body slices as the second column:")
        print("(The file selection screen may appear BEHIND your current application)")
        Tk().withdraw()
        inputFile = askopenfilename()
        real_slices = pullData(inputFile, head = None) 
        real_slices.columns = ['image', 'area']
        real_slices = real_slices['area']
        print(">>Now select the csv file that contains your simulated data.  It must have the area of the body slices in a column labeled 'area_scaled':")
        print("(The file selection screen may appear BEHIND your current application)")
        Tk().withdraw()
        inputFile = askopenfilename()
        sim_slices = pullData(inputFile)
        print(sim_slices.head())
        sim_slices = sim_slices[sim_slices.time != 'time'].dropna(axis = 0)  #Removing non-number rows (left-over headers) and NaN's.   
        sim_slices = sim_slices[['area_scaled', 'size_mu', 'size_sigma']].astype(float) #So we can filter by mu or sigma later
        print(sim_slices.head()) 
        print ('Your body area data has been loaded and is ready to use')
        return real_slices, sim_slices

def loadDataNumber(fileSelectOpt):
    if fileSelectOpt  == True:
        print(">>Select the csv file that contains your real data.  It must have the number of body slices per image in the second column:")
        print("(The file selection screen may appear BEHIND your current application)")
        Tk().withdraw()
        inputFile = askopenfilename()
        real_slices = pullData(inputFile, head = None) 
        real_slices.columns = ['image', 'number']
        # Adding zeros for the empty images. Verified to work.  
        noBodies = int(input("How many additional vacuole images were not analyzed because they did not contain any bodies?"))
        if noBodies > 0:
            real_slices = real_slices['number'].astype(int)  
            addZeros = ([0]*noBodies)
            addZeros = pd.DataFrame(addZeros, dtype = int)
            real_slices = pd.concat([real_slices, addZeros], ignore_index = True) 
            real_slices.columns = ['number']
        real_body_number = real_slices['number'].astype(int) 
        print(real_body_number.head())  
        #print(real_slices.dtypes)
        print(real_body_number.value_counts())  #For verification
        print(">>Now select the csv file that contains your simulated data.  In this case the 'body_number' column contains a unique identifying number for each body sliced:")
        print("(The file selection screen may appear BEHIND your current application)")
        Tk().withdraw()
        inputFile = askopenfilename()
        sim_slices = pullData(inputFile)
        size_mus = sorted(sim_slices['size_mu'].value_counts().index.tolist())[:-1]  #extracts all of the different values of mu, sorted, and removes the last value (the column header)
        print("size mus", size_mus)
        size_sigmas = sorted(sim_slices['size_sigma'].value_counts().index.tolist())[:-1]
        print("size sigmas", size_sigmas)
        number_mus = sorted(sim_slices['number_mu'].value_counts().index.tolist())[:-1] 
        print("number mus", number_mus)
        number_sigmas = sorted(sim_slices['number_sigma'].value_counts().index.tolist())[:-1]
        print("number sigmas", number_sigmas)
        sim_body_numbers = pd.DataFrame()  #Creating an empty dataframe to hold the final body number data
        for size_mu in size_mus: 
            split_data = sim_slices.loc[sim_slices['size_mu'] == size_mu]  #splitting up the data
            for size_sigma in size_sigmas:
                split_data2 = split_data.loc[split_data['size_sigma'] == size_sigma]
                for number_mu in number_mus:
                    split_data3 = split_data2.loc[split_data2['number_mu'] == number_mu]
                    for number_sigma in number_sigmas:
                        split_slices = split_data3.loc[split_data3['number_sigma'] == number_sigma]
                        split_slices = split_slices[sim_slices.time != 'time']  #Removing non-number rows (left-over headers).  This works 
                        split_slices = split_slices.dropna( axis = 0)   #Removing rows that had "NaN" because there were no bodies captured in that slice
                        empty_slice_num = split_slices.shape[0] - split_slices.shape[0]   #Calculating the number of rows that had "NaN" because there were no bodies captured in that slice
                        empty_slices = [0]*empty_slice_num      #Creating a list of 0's to represent the empty slices
                        sim_body_number = pd.DataFrame({'number': split_slices['time'].value_counts().to_list()})  #The number of unique timestamps is the number of bodies in the slice                        sim_body_number = pd.concat([sim_body_number, pd.DataFrame({'number' : empty_slices })], ignore_index = True)   #Adding in the rows for the empty slices
                        sim_body_number = pd.concat([sim_body_number, pd.DataFrame({'number' : empty_slices })], ignore_index = True)   #Adding in the rows for the empty slices
                        size_mu_list = [float(size_mu)]*len(sim_body_number)  #Creating a list of the size_mu value to add to the dataframe
                        size_sigma_list = [float(size_sigma)]*len(sim_body_number)
                        number_mu_list = [float(number_mu)]*len(sim_body_number)  
                        number_sigma_list = [float(number_sigma)]*len(sim_body_number)
                        sim_body_number['size_mu'] = size_mu_list #Adding the size_mu value to the dataframe
                        sim_body_number['size_sigma'] = size_sigma_list  #Adding the size_sigma value to the dataframe
                        sim_body_number['number_mu'] = number_mu_list  #Adding the number_mu value  to the dataframe
                        sim_body_number['number_sigma'] = number_sigma_list  #Adding the number_sigma value to the dataframe
                        #print("single slice", sim_body_number.head())  #For verification  
                        sim_body_numbers = pd.concat([sim_body_numbers, sim_body_number], ignore_index = True)  # putting it all together
        print(sim_body_numbers.head())  #For verification
        # with open('sim_body_numbers.csv', 'w') as f:  #Saving the simulated body numbers to a csv file for verfication
        #     sim_body_numbers.to_csv(f, index = False)
        print ('Your body number data has been loaded and is ready to use')
        return real_body_number, sim_body_numbers

def loadDataMessage():
    print('Remember that you must load your data before performing a test, and it must be in the proper format')
    print('The real data must have either body areas or body number in the second column, depending on which you are estimating.')
    print('The simulated data (from slicestats) should have columns labeled "area_scaled" and "body_number.')

def pullData(dataFile, head = 0):
    inStream = open(dataFile, "r")
    slices = pd.read_csv(inStream, header = head)
    inStream.close()
    return slices
 

def findAverage_size(real, sim):
    data = real   
    # Summarizes the real data from the real slices
    print ("\nHere are the statistics for your real data:") 
    print(f"You have slices from {len(data)} bodies.")
    print("Average Body Slice Area = %d" %(data.mean()))
    print("Largest Body Slice Area = %d" %(data.max()))
    print("Smallest Body Slice Area = %d" %(data.min()))
    print("Standard Deviation of data set = %d" %(data.std()))

    # Summarizes the simulated data from the simulated slices
    columns = ['mu', 'sigma', 'length', 'average', 'largest', 'smallest', 'stdDev']
    multi_results = pd.DataFrame(columns = columns)
    mus = sorted(sim['size_mu'].value_counts().index.tolist())      # Extracts all of the different values of mu, sorted
    sigmas = sorted(sim['size_sigma'].value_counts().index.tolist())      # Extracts all of the different values of sigma

    for mu in mus:
        split_data = sim.loc[sim['size_mu'] == mu]
        for sigma in sigmas:
            splitter_data = split_data.loc[split_data['size_sigma'] == sigma]
            data = splitter_data['area_scaled']
            Length = len(data)
            Average = data.mean()
            Largest = data.max()
            Smallest = data.min()
            stdDev = data.std()
            results = pd.DataFrame([[mu, sigma, Length, Average, Largest, Smallest, stdDev]], columns = columns)
            multi_results = pd.concat([multi_results, results], ignore_index= True)
    print("\nHere are the statistics for your simulated data:")
    print(multi_results)


def findAverage_num(real, sim):
    data = real   
    # Summarizes the real data from the real slices
    print ("\nHere are the statistics for your real data:") 
    print(f"You have slices from {len(data)} images.")
    print("Average Body Number per Slice = %d" %(data.mean()))
    print("Largest Body Number per Slice = %d" %(data.max()))
    print("Smallest Body Number per Slice = %d" %(data.min()))
    print("Standard Deviation of data set = %d" %(data.std()))

    # Summarizes the simulated data from the simulated slices
    sim_slices = sim
    
    size_mus = sorted(sim_slices['size_mu'].value_counts().index.tolist())  #extracts all of the different values of mu, sorted
    size_sigmas = sorted(sim_slices['size_sigma'].value_counts().index.tolist())
    number_mus = sorted(sim_slices['number_mu'].value_counts().index.tolist())
    number_sigmas = sorted(sim_slices['number_sigma'].value_counts().index.tolist())
    columns = ['size_mu', 'size_sigma', 'number_mu', 'number_sigma', 'length', 'average', 'largest', 'smallest', 'stdDev']
    multi_results = pd.DataFrame(columns = columns)
    for size_mu in size_mus: 
            split_data = sim_slices.loc[sim_slices['size_mu'] == size_mu]  #splitting up the data
            for size_sigma in size_sigmas:
                split_data2 = split_data.loc[split_data['size_sigma'] == size_sigma]
                for number_mu in number_mus:
                    split_data3 = split_data2.loc[split_data2['number_mu'] == number_mu]
                    for number_sigma in number_sigmas:
                        split_slices = split_data3.loc[split_data3['number_sigma'] == number_sigma]
                        data = split_slices['number']
                        Length = len(data)
                        Average = data.mean()
                        Largest = data.max()
                        Smallest = data.min()
                        stdDev = data.std()
                        results = pd.DataFrame([[size_mu, size_sigma, number_mu, number_sigma, Length, Average, Largest, Smallest, stdDev]], columns = columns)
                        multi_results = pd.concat([multi_results, results], ignore_index= True)
    print("\nHere are the statistics for your simulated data:")
    print(multi_results)
    # with open('sim_body_statistics.csv', 'w') as f:  #Saving the simulated body statistics to a csv file for verfication
    #     multi_results.to_csv(f, index = False)  


def ksTest_area(real, sim):
    sim = sim['area_scaled']
    ks = stats.ks_2samp(real, sim)
    #print (f"The Kolmogorov-Smirnov statistic for your two data sets is {ks.statistic:.3f}, and the p-value is {ks.pvalue:.2E}. \n")
    return ks

def ksTest_number(real, sim):
    sim = sim['number']
    ks = stats.ks_2samp(real, sim)
    #print (f"The Kolmogorov-Smirnov statistic for your two data sets is {ks.statistic:.3f}, and the p-value is {ks.pvalue:.2E}. \n")
    return ks

def multiKS_area(real, sim):
    print(sim.head())
    mus = sim['size_mu'].value_counts().index.tolist()      # Extracts all of the different values of mu
    mu_list = sorted(mus) 
    print(mu_list)
    #print(type(mu_list))
    sigmas = sim['size_sigma'].value_counts().index.tolist()      # Extracts all of the different values of sigma
    sigma_list = sorted(sigmas)
    print(sigma_list)
    #print(type(sigma_list))
    multi_ks_results = pd.DataFrame(columns = ['mu', 'sigma', 'ks'])
    for mu in mu_list:
        split_data = sim.loc[sim['size_mu'] == mu]
        for sigma in sigma_list:
            splitter_data = split_data.loc[split_data['size_sigma'] == sigma]
            ks = ksTest_area(real, splitter_data)
            ks_results = pd.DataFrame([[mu, sigma, float(ks.statistic)]], columns = ['mu', 'sigma', 'ks'])
            multi_ks_results = pd.concat([multi_ks_results, ks_results], ignore_index= True)
    sorted_ks_results = multi_ks_results.sort_values(by = 'ks')        
    return sorted_ks_results 

def multiKS_number(real, sim):
    size_mu = input("Input the size mu you want to use (run the program in size mode to find this): ")
    size_sigma = input("Input the size sigma you want to use (run the program in size mode to find this): ")
    print(sim.head())
    # print(sim.dtypes)
    sim = sim[(sim['size_mu']) == float(size_mu)]  #filters the data to only include the specified size mu
    print(sim.head()) 
    sim = sim[(sim['size_sigma']) == float(size_sigma)]  #filters the data to only include the specified size sigma
    print(sim.head())
    if len(sim) == 0:
        print("No data found for that size mu and sigma combination - either choose different values or run the program in size mode to find valid values")
        return
    mus = sim['number_mu'].value_counts().index.tolist()      # Extracts all of the different values of number mu
    mu_list = sorted(mus) 
    print(mu_list)
    #print(type(mu_list))
    sigmas = sim['number_sigma'].value_counts().index.tolist()      # Extracts all of the different values of number sigma
    sigma_list = sorted(sigmas)
    print(sigma_list)
    #print(type(sigma_list))
    multi_ks_results = pd.DataFrame(columns = ['mu', 'sigma', 'ks'])
    for mu in mu_list:
        split_data = sim.loc[sim['number_mu'] == mu]
        for sigma in sigma_list:
            splitter_data = split_data.loc[split_data['number_sigma'] == sigma]
            ks = ksTest_number(real, splitter_data)
            ks_results = pd.DataFrame([[mu, sigma, float(ks.statistic)]], columns = ['mu', 'sigma', 'ks'])
            multi_ks_results = pd.concat([multi_ks_results, ks_results], ignore_index= True)
    sorted_ks_results = multi_ks_results.sort_values(by = 'ks')        
    return sorted_ks_results 

def KS_heatmap(ks_results):
    ks_pivot = ks_results.pivot(index = 'sigma', columns = 'mu', values = 'ks')
    print(ks_pivot)
    plt.figure(figsize = (10,8))
    sns.heatmap(ks_pivot, annot = True, cmap = 'viridis')
    plt.title('KS statistic for different mu and sigma values')
    plt.xlabel('mu values')
    plt.ylabel('sigma values')
    plt.show()

def qqPlot_area(real, sim):
    print('Choose the values of size_mu and size_sigma you want to use for the Q-Q plot - for example, the values that gave the lowest KS statistic.')
    size_mu = input("Input the size_mu you want to use: ")
    size_sigma = input("Input the size_sigma you want to use: ")
    sim = sim[(sim['size_mu']) == float(size_mu)]  #filters the data to only include the specified size mu
    sim = sim[(sim['size_sigma']) == float(size_sigma)]  #filters the data to only include the specified size sigma
    sim = sim['area_scaled']

    plotA = sm.ProbPlot(real)
    plotB = sm.ProbPlot(sim)
    qqplot_2samples(plotA,plotB, line='r', xlabel = 'Quantiles of Experimental Data', ylabel ='Quantiles of Simulated Data')  
    
    plt.show()

#END OF qqPlot


def violinPlot_area(real, sim):
    print('Choose the values of size_mu and size_sigma you want to use for the violin plot - for example, the values that gave the lowest KS statistic.')
    size_mu = input("Input the size_mu you want to use: ")
    size_sigma = input("Input the size_sigma you want to use: ")
    sim = sim[(sim['size_mu']) == float(size_mu)]  #filters the data to only include the specified size mu
    sim = sim[(sim['size_sigma']) == float(size_sigma)]  #filters the data to only include the specified size sigma
    sim = sim['area_scaled']
    data = [real, sim]
    
    
    fig=plt.figure()
    ax = fig.add_subplot(111)   
    sm.graphics.violinplot(data, ax=ax, labels=["Experimental Data", "Simulated Data"])
    ax.set_xlabel("Data Sets")
    ax.set_ylabel("Body Crossectional Area (square nm)")   
    plt.show()


 
main()
