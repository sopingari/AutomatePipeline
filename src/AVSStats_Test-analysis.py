# -*- coding: utf-8 -*-
import random
import scipy.stats as stats
import statsmodels.api as sm
import numpy as np
import matplotlib.pyplot as plt
import pandas as pd 
from statsmodels.graphics.gofplots import qqplot_2samples
from tkinter import Tk
from tkinter.filedialog import askopenfilename

############################################################################################################
#   Eastern Michigan University
#   Backues Lab  
#   Author: Payton Dunning and Steven Backues
#   Last Date Modified: November 18th, 2024
#
#   Includes various statistical functions for analyzing body data generated by SliceStats.
############################################################################################################
#   This program is free software: you can redistribute it and/or modify
#   it under the terms of the GNU General Public License as published by
#   the Free Software Foundation, either version 3 of the License, or
#   (at your option) any later version.
#
#   This program is distributed in the hope that it will be useful,
#   but WITHOUT ANY WARRANTY; without even the implied warranty of
#   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#   GNU General Public License for more details.
#
#   You should have received a copy of the GNU General Public License
#   along with this program.  If not, see <https://www.gnu.org/licenses/>.
############################################################################################################

def main(fileSelectOpt = True, manual = True, seed = None):
    if seed is None:
        seed = random.randint(1, 1000000)  # Generate a random seed if not provided
    random.seed(seed)
    np.random.seed(seed)
    rng = np.random.default_rng(seed)
    
    if manual == True:  
        print(">>Please select an option: ")
        print("[1]: Compare the body size radii distribution to its expected distribution")
        print("[2]: Compare the body number distribution to its expected distribution")
        print("[3]: Compare the vacuole radius distribution to its expected distribution")
        programMode = input()

        for _ in range(100):     #So that the user can run multiple tests
            print(">>Please select an option: ")
            print("[1]: Load your data")  ### Works  
            #print("[2]: Calculate statistics on your data")  
            print("[3]: Perform KS (Kolmogorov-Smirnov test)")   ### Works 
            # print("[4]: Generate a Q-Q (quantile-quantile) plot)")   
            # print("[5]: Generate a Violin Plot")   
            print("[6]: Choose which type of data to analyze")
            print("[7]: Compare two expected distributions to see how much they vary")
            print("[0]: Exit Script")
            
            userSelection = input()
            if(userSelection == "1"):
                if programMode == "1":
                    sim_slices = loadDataArea(fileSelectOpt)
                elif programMode == "2":
                    sim_slices = loadDataNumber(fileSelectOpt)
                elif programMode == "3":
                    sim_slices = loadVacSize(fileSelectOpt)
                else: 
                    print("Please choose option 1 through 3 by typing that number")
                    print("[1]: Estimate body size from body slice areas")
                    print("[2]: Estimate body number from number of bodies per image")
                    print("[3]: Compare the vacuole radius distribution to its expected distribution")
                    programMode = input() 
            # if(userSelection == "2"):
            #     findAverage_size(real = real_slices, sim = sim_slices)

            elif(userSelection == "3"):
                if programMode =="2":
                    results, sorted_results = multiKS(sim=sim_slices, rounded = True)
                else:
                    results, sorted_results = multiKS(sim=sim_slices, rounded = False)
                results.to_csv('avs_testing_results.csv', index = False)
                print(results)


            # elif(userSelection == "4"):
            #     qqPlot(real = real_slices, sim = sim_slices)
            # elif(userSelection == "5"):
            #     violinPlot(real = real_slices, sim = sim_slices, prog = programMode)
            elif(userSelection == "6"):
                print('NOTE!! You will need to reload your data after this for it to be valid')
                print("[1]: Compare the body size radii distribution to its expected distribution")
                print("[2]: Compare the body number distribution to its expected distribution")
                print("[3]: Compare the vacuole radius distribution to its expected distribution")
                programMode = input()

            elif(userSelection == "7"):
                print("Enter the mu of the lognormal distribution to test")
                mu = float(input())   
                print("Enter the sigma of the lognormal distribution to test")
                sigma = float(input()) 
                print("Enter the number of simulated samples to create")
                sample_num = int(input())
                r_normals = rng.standard_normal(sample_num)*sigma+mu # one for each APB
                radii = np.exp(r_normals)
                rv = stats.lognorm(s=sigma, scale=np.exp(mu))
                expected_radii = rv.rvs(size=10000)
                ks = stats.kstest(radii, expected_radii)
                print (f"The Kolmogorov-Smirnov statistic for your data is {ks.statistic:.3f}, and the p-value is {ks.pvalue:.2E}. \n")

            elif(userSelection == "0"):
                raise SystemExit
            else:
                print("Please choose an option 0 through 5 by typing that number")
    else:
        print("Coming soon: Automated analysis of multiple runs to find the best mu and sigma ")

def loadDataArea(fileSelectOpt):
    if fileSelectOpt  == True:
        print(">>Select the csv file that contains the data output from vacuole_gen.  It must have the radius of the body slices in a column labeled 'radius':")
        print("(The file selection screen may appear BEHIND your current application)")
        Tk().withdraw()
        inputFile = askopenfilename()
        sim_slices = pullData(inputFile)
        print(sim_slices.head())
        sim_slices = sim_slices[sim_slices.type != 'type'].dropna(axis = 0)  #Removing non-number rows (left-over headers) and NaN's.   
        sim_slices = sim_slices[['radius', 'Body_Radius_Mu', 'Body_Radius_Sigma']].astype(float) #So we can filter by mu or sigma later
        sim_slices = sim_slices.rename(columns={'radius': 'value', 'Body_Radius_Mu':'mu', 'Body_Radius_Sigma':'sigma'})  #Make generic for multi-KS
        print(sim_slices.head()) 
        print ('Your body radius data has been loaded and is ready to use')
        return sim_slices

def loadDataNumber(fileSelectOpt):
    if fileSelectOpt  == True:
        Tk().withdraw()
        inputFile = askopenfilename()
        sim_slices = pullData(inputFile)
        sim_slices = sim_slices[['Number_of_Bodies_Placed', 'Body_Number_Mu', 'Body_Number_Sigma']].astype(float) #So we can filter by mu or sigma later
        sim_slices = sim_slices.rename(columns={'Number_of_Bodies_Placed': 'value', 'Body_Number_Mu':'mu', 'Body_Number_Sigma':'sigma'}) #Make generic for multi-KS
        print(sim_slices.head()) 
        print ('Your body number data has been loaded and is ready to use')
        return sim_slices
    
def loadVacSize(fileSelectOpt):
    if fileSelectOpt  == True:
        Tk().withdraw()
        inputFile = askopenfilename()
        sim_slices = pullData(inputFile)
        sim_slices = sim_slices[['Vacuole_Inner_Radius', 'Wall_Radius_Mu', 'Wall_Radius_Sigma']].astype(float) #So we can filter by mu or sigma later
        sim_slices = sim_slices.rename(columns={'Vacuole_Inner_Radius': 'value', 'Wall_Radius_Mu':'mu', 'Wall_Radius_Sigma':'sigma'}) #Make generic for multi-KS
        print(sim_slices.head()) 
        print ('Your vacuole radius data has been loaded and is ready to use')
        return sim_slices

def loadDataMessage():
    print('Remember that you must load your data before performing a test, and it must be in the proper format')
    print('The real data must have either body areas or body number in the second column, depending on which you are estimating.')
    print('The simulated data (from slicestats) should have columns labeled "area_scaled" and "body_number.')

def pullData(dataFile, head = 0):
    inStream = open(dataFile, "r")
    slices = pd.read_csv(inStream, header = head)
    inStream.close()
    return slices
 



def findAverage_size(sim):
    sim = sim['value']
    data_sets = [sim]
    which_data = 1
    for data in data_sets:
        dataLength = len(data)
        areaAverage = data.mean()
        largestArea = data.max()
        smallestArea = data.min()
        stdDev = data.std()
    
        if which_data == 0:
            print ("\nHere are the statistics for your real data:") 
        else:
            print("\nHere are the statistics for your simulated data:")
        print(f"You have radii from {dataLength} bodies.")
        print("Average Body radius = %d" %(areaAverage))
        print("Largest Body radius = %d" %(largestArea))
        print("Smallest Body radius = %d" %(smallestArea))
        print("Standard Deviation of data set = %d" %(stdDev))
        which_data += 1

def findAverage_num(real, sim):
    data_sets = [real, sim]
    which_data = 0
    for data in data_sets:
        dataLength = len(data)
        areaAverage = data.mean()
        largestArea = data.max()
        smallestArea = data.min()
        stdDev = data.std()
    
        if which_data == 0:
            print ("\nHere are the statistics for your real data:") 
        else:
            print("\nHere are the statistics for your simulated data:")
        print(f"You have slices from {dataLength} images.")
        print("Average Number of Bodies per Image = %d" %(areaAverage))
        print("Largest Number of Bodies per Image = %d" %(largestArea))
        print("Smallest Number of Bodies per Image = %d" %(smallestArea))
        print("Standard Deviation of data set = %d" %(stdDev))
        which_data += 1


def ksTest(sim, mu, sigma, rounded = False):
    values = sim['value']
    rv = stats.lognorm(s=sigma, scale=np.exp(mu))
    expected_values = rv.rvs(size=10000)
    if rounded == True:
        expected_values = expected_values.round(decimals = 0)
    ks = stats.kstest(values, expected_values)
    print (f"The Kolmogorov-Smirnov statistic for your two data sets is {ks.statistic:.3f}, and the p-value is {ks.pvalue:.2E}. \n")
    # ks2 = stats.kstest(real, sim)
    # print (f"Or, the Kolmogorov-Smirnov statistic for your two data sets is {ks2.statistic:.3f}, and the p-value is {ks2.pvalue:.2E}. \n")
    return ks

def multiKS(sim, rounded = False):
    mus = sim['mu'].value_counts().index.tolist()      # Extracts all of the different values of mu
    mu_list = sorted(mus) 
    print(mu_list)
    print(type(mu_list))
    sigmas = sim['sigma'].value_counts().index.tolist()      # Extracts all of the different values of sigma
    sigma_list = sorted(sigmas)
    print(sigma_list)
    print(type(sigma_list))
    multi_ks_results = pd.DataFrame(columns = ['mu', 'sigma', 'ks'])
    for mu in mu_list:
        split_data = sim.loc[sim['mu'] == mu]
        for sigma in sigma_list:
            splitter_data = split_data.loc[split_data['sigma'] == sigma]
            ks = ksTest(splitter_data, mu, sigma, rounded=rounded)
            ks_results = pd.DataFrame([[mu, sigma, float(ks.statistic), float(ks.pvalue), len(splitter_data)]], columns = ['mu', 'sigma', 'ks', 'p-value', 'samples'])
            multi_ks_results = pd.concat([multi_ks_results, ks_results], ignore_index= True)
    sorted_ks_results = multi_ks_results.sort_values(by = 'ks')        
    return multi_ks_results, sorted_ks_results 

def qqPlot(real, sim):


    sim = sim['area_scaled']
    #statsmodels.graphics.gofplots.qqplot_2samples(statsA, statsB, xlabel='Real Data', ylabel='Simulated Data')
    plotA = sm.ProbPlot(real)
    plotB = sm.ProbPlot(sim)
    qqplot_2samples(plotA,plotB, line='r', xlabel = 'Quantiles of Experimental Data', ylabel ='Quantiles of Simulated Data')  
    
    plt.show()

#END OF qqPlot


def violinPlot(real, sim, prog):
    fig=plt.figure()
    ax = fig.add_subplot(111)
    sim = sim['area_scaled']
    data = [real, sim]
    
    sm.graphics.violinplot(data, ax=ax, labels=["Experimental Data", "Simulated Data"])
    
    ax.set_xlabel("Data Sets")
    if prog == '1':
        ax.set_ylabel("Body Crossectional Area (square nm)")
    elif prog == '2':
        ax.set_ylabel("Number of bodies per slice")
    
    plt.show()


 
main()
